% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SincastImpute.R
\name{SincastImpute}
\alias{SincastImpute}
\title{Sincast imputation}
\usage{
SincastImpute(
  object,
  assay = NULL,
  features = NULL,
  npcs = NULL,
  t = 3,
  k = 30,
  knn = NULL,
  do.umap.dist = TRUE,
  a = NULL,
  do.laplacian = TRUE,
  norm = c("probabilistic", "average"),
  do.post.scale = TRUE,
  preserve.zero = TRUE,
  lra.control = list(),
  ret.graph = TRUE,
  ndcs = 10,
  replace = FALSE,
  ...
)

\S4method{SincastImpute}{Sincast}(
  object,
  assay = NULL,
  features = NULL,
  npcs = NULL,
  t = 3,
  k = 30,
  knn = NULL,
  do.umap.dist = TRUE,
  a = NULL,
  do.laplacian = TRUE,
  norm = c("probabilistic", "average"),
  do.post.scale = TRUE,
  preserve.zero = TRUE,
  lra.control = list(),
  ret.graph = TRUE,
  ndcs = 10,
  replace = FALSE,
  ...
)
}
\arguments{
\item{object}{A \code{Sincast} object.}

\item{assay}{Name of the \code{Seurat} assay imputation is being run on. Default is the default \code{Seurat} assay.}

\item{features}{Features to impute. Default is all features in the assay.}

\item{npcs}{How many principal components to compute on the query data. The PCs will be used to construct the knn graph.}

\item{t}{Diffusion time, or the power of Markov transition matrix.}

\item{k}{The number of neighbors used to infer adaptive Gaussian kernel for each cell.}

\item{knn}{A cell can only be connected to knn neighbors when t is set 1.}

\item{do.umap.dist}{Logical; if TRUE, scale Euclidean distances to distances beyond nearest neighbors as in the UMAP algorithm.}

\item{a}{Default: log2(k) and log(k/(k-1)) when setting umap.dist to TRUE and FALSE respectively.
a < 1 represents the probability of a cell communicating with its kth nearest neighbor.
a > 1 represents the sum of probabilities of a cell communicating with its k nearest neighbors.}

\item{do.laplacian}{Logical; if TRUE, perform Laplacian normalization on the affinity matrix.}

\item{norm}{How to symmetrize the affinity matrix. Default is Probabilistic t-norm. The other option is 'average'.}

\item{do.post.scale}{Logical; if TRUE, perform post-imputation scaling, which match the scale of \code{Sincast} imputed data
with the data imputed by low rank approximation (See \code{\link[Sincast]{LowRankApprox}}). After scale matching,
the average of the low rank approximation and the scaled \code{Sincast} imputation will be returned as the final imputed
data.}

\item{preserve.zero}{Logical; if TRUE, perform zero-preserving low rank approximation on the \code{Sincast} imputed data.
(See \code{\link[Sincast]{LowRankApprox}}).}

\item{lra.control}{A list of arguments to \code{\link[Sincast]{LowRankApprox}} function call .}

\item{ret.graph}{Logical; if TRUE, return the diffusion operator and store it in the \code{graph} slot of the imputation assay.}

\item{ndcs}{Calculate \code{ndcs} number of diffusion components by eigen decomposing the diffusion operator.
Resulting cell embedding is stored in the \code{reduction} slot of the imputation assay.}

\item{replace}{Logical; if TRUE, replace the existing \code{pseudobulk} assay.}
}
\value{
A \code{Sincast} object with updated \code{imputation} assay.
}
\description{
Perform Sincast imputation.
}
\seealso{
\code{\link[Sincast]{SincastAggregate}()}, \code{\link[Sincast]{LowRankApprox}()}
}
